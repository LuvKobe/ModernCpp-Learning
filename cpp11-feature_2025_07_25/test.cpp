#include <iostream>
#include <string>
using namespace std;

// 抽象类
/*
概念
在虚函数的后面写上=0，则这个函数为纯虚函数。
包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。
*/

// class Car
// {
// public:
// 	// 纯虚函数
// 	virtual void Drive() = 0;
// };

// //派生类继承抽象类后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。

// //子类
// class Benz : public Car
// {
// public:	
// 	//重写纯虚函数
// 	virtual void Drive()
// 	{
// 		cout << "Benz-舒适" << endl;
// 	}
// };

// // 子类
// class BMW : public Car
// {
// public:
// 	//重写纯虚函数
// 	virtual void Drive()
// 	{
// 		cout << "BMW-操控" << endl;
// 	}
// };

// int main()
// {
// 	//Car c; //抽象类不能实例化出对象，error
// 	Benz b1;
// 	BMW b2;

// 	//不同对象用基类指针调用Drive函数，完成不同的行为
// 	Car* p1 = &b1;
// 	Car* p2 = &b2;
// 	p1->Drive();
// 	p2->Drive();
// 	cout << endl;

// 	//不同对象用基类引用调用Drive函数，完成不同的行为
// 	Car &p3 = b1;
// 	Car &p4 = b2;
// 	p3.Drive();
// 	p4.Drive();
	
	
// 	return 0;
// }

//抽象类既然不能实例化出对象，那抽象类存在的意义是什么？
/*
1. 抽象类可以更好的去表示现实世界中，没有实例对象对应的抽象类型，比如：植物、人、动物等。

2. 抽象类很好的体现了虚函数的继承是一种接口继承，
强制子类去重写纯虚函数，因为子类若是不重写从父类继承下来的纯虚函数，
那么子类也是抽象类也不能实例化出对象。
*/

/*
接口继承和实现继承

实现继承：普通函数的继承是一种实现继承，派生类继承了基类函数的实现，可以使用该函数。

接口继承：虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态。

建议： 所以如果不实现多态，就不要把函数定义成虚函数。
*/

///////////////////////////////////////////////////////////////////////////////////

/*
多态的原理：虚函数表
*/

//下面是一道常考的笔试题：Base类实例化出对象的大小是多少？
// class Base
// {
// public:
// 	virtual void Func1()
// 	{
// 		cout << "Func1()" << endl;
// 	}
// private:
// 	int _b = 1;
// };

// //通过观察测试，我们发现Base类实例化的对象b的大小是8个字节。
// int main()
// {
// 	Base b;
// 	cout << sizeof(b) << endl; //8
// 	return 0;
// }

/*
b对象当中除了_b成员外，实际上还有一个_vfptr放在对象的前面。

比如：
|_vfptr|
|  _b  |

对象中的这个指针叫做虚函数表指针，简称虚表指针，
虚表指针指向一个虚函数表，简称虚表，每一个含有虚函数的类中都至少有一个虚表指针。

*/

//父类
// class Base
// {
// public:
// 	//虚函数
// 	virtual void Func1()
// 	{
// 		cout << "Base::Func1()" << endl;
// 	}
// 	//虚函数
// 	virtual void Func2()
// 	{
// 		cout << "Base::Func2()" << endl;
// 	}
// 	//普通成员函数
// 	void Func3()
// 	{
// 		cout << "Base::Func3()" << endl;
// 	}
// private:
// 	int _b = 1;
// };

// //子类
// class Derive : public Base
// {
// public:
// 	//重写虚函数Func1
// 	virtual void Func1()
// 	{
// 		cout << "Derive::Func1()" << endl;
// 	}
// private:
// 	int _d = 2;
// };

// int j = 0;
// int main()
// {
// 	Base b;
// 	Base* p = &b;
// 	printf("vfptr:%p\n", *((int*)p)); //000FDCAC
// 	int i = 0;
// 	printf("栈上地址:%p\n", &i);       //005CFE24
// 	printf("数据段地址:%p\n", &j);     //0010038C

// 	int* k = new int;
// 	printf("堆上地址:%p\n", k);       //00A6CA00
// 	char* cp = "hello world";
// 	printf("代码段地址:%p\n", cp);    //000FDCB4
// 	return 0;
// }


/*
通过调试可以发现，父类对象b和基类对象d当中除了自己的成员变量之外，
父类和子类对象都有一个虚表指针，分别指向属于自己的虚表。

实际上虚表当中存储的就是虚函数的地址，
因为父类当中的Func1和Func2都是虚函数，
所以父类对象b的虚表当中存储的就是虚函数Func1和Func2的地址。

而子类虽然继承了父类的虚函数Func1和Func2，但是子类对父类的虚函数Func1进行了重写，
因此，子类对象d的虚表当中存储的是父类的虚函数Func2的地址和重写的Func1的地址。
这就是为什么虚函数的重写也叫做覆盖，
覆盖就是指虚表中虚函数地址的覆盖，重写是语法的叫法，覆盖是原理层的叫法。

其次需要注意的是：Func2是虚函数，所以继承下来后放进了子类的虚表，
而Func3是普通成员函数，继承下来后不会放进子类的虚表。
此外，虚函数表本质是一个存虚函数指针的指针数组，一般情况下会在这个数组最后放一个nullptr。
*/

//总结一下，派生类的虚表生成步骤如下：
/*
1. 先将基类中的虚表内容拷贝一份到派生类的虚表。
2. 如果派生类重写了基类中的某个虚函数，则用派生类自己的虚函数地址覆盖虚表中基类的虚函数地址。
3. 派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。
*/

//虚表是什么阶段初始化的？虚函数存在哪里？虚表存在哪里？
/*
虚表实际上是在构造函数初始化列表阶段进行初始化的，
注意虚表当中存的是虚函数的地址不是虚函数，虚函数和普通函数一样，都是存在代码段的，
只是他的地址又存到了虚表当中。
另外，对象中存的不是虚表而是指向虚表的指针。
*/

//那到底多态的原理是什么？

//父类
// class Person
// {
// public:
// 	virtual void BuyTicket()
// 	{
// 		cout << "买票-全价" << endl;
// 	}
// 	int _p = 1;
// };


// //子类
// class Student : public Person
// {
// public:
// 	virtual void BuyTicket()
// 	{
// 		cout << "买票-半价" << endl;
// 	}
// 	int _s = 2;
// };


// int main()
// {
// 	Person Mike;
// 	Student Johnson;

// 	Johnson._p = 3; //以便观察是否完成切片

// 	Person* p1 = &Mike;
// 	Person* p2 = &Johnson;

// 	p1->BuyTicket(); //买票-全价
// 	p2->BuyTicket(); //买票-半价

// 	Person& p3 = Mike;
// 	Person& p4 = Johnson;
// 	p3.BuyTicket();
// 	p4.BuyTicket();
// 	return 0;
// }

/*
通过调试可以发现:
对象Mike中包含一个成员变量_p和一个虚表指针，
对象Johnson中包含两个成员变量_p和_s以及一个虚表指针，
这两个对象当中的虚表指针分别指向自己的虚表。

围绕此图分析便可得到多态的原理：

1、父类指针p1指向Mike对象，p1->BuyTicket在Mike的虚表中找到的虚函数就是Person::BuyTicket。
2、父类指针p2指向Johnson对象，p2>BuyTicket在Johnson的虚表中找到的虚函数就是Student::BuyTicket。

这样就实现出了不同对象去完成同一行为时，展现出不同的形态。
*/

/*
现在想想多态构成的两个条件，
一是完成虚函数的重写，
二是必须使用父类的指针或者引用去调用虚函数。

必须完成虚函数的重写是因为我们需要完成子类虚表当中虚函数地址的覆盖，

那为什么必须使用父类的指针或者引用去调用虚函数呢？为什么使用父类对象去调用虚函数达不到多态的效果呢？

Person* p1 = &Mike;
Person& p2 = Mike;

使用父类指针或者引用时，实际上是一种切片行为，切片时只会让父类指针或者引用得到父类对象或子类对象中切出来的那一部分。

构成多态，指向谁就调用谁的虚函数，跟对象有关。
不构成多态，对象类型是什么就调用谁的虚函数，跟类型有关。
*/


/////////////////////////////////////////////////////////////////////////////

/*
静态绑定： 静态绑定又称为前期绑定(早绑定)，在程序编译期间确定了程序的行为，也成为静态多态，比如：函数重载。

动态绑定： 动态绑定又称为后期绑定(晚绑定)，在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。
*/

//父类
// class Person
// {
// public:
// 	virtual void BuyTicket()
// 	{
// 		cout << "买票-全价" << endl;
// 	}
// };

// //子类
// class Student : public Person
// {
// public:
// 	virtual void BuyTicket()
// 	{
// 		cout << "买票-半价" << endl;
// 	}
// };

// int main()
// {
// 	Student Johnson;
// 	Person p = Johnson; //不构成多态
// 	p.BuyTicket();
// 	return 0;
// }

//单继承中的虚函数表
//基类
// class Base
// {
// public:
// 	virtual void func1() 
// 	{ 
// 		cout << "Base::func1()" << endl; 
// 	}

// 	virtual void func2() 
// 	{ 
// 		cout << "Base::func2()" << endl; 
// 	}
// private:
// 	int _a;
// };

// //派生类
// class Derive : public Base
// {
// public:
// 	virtual void func1() 
// 	{ 
// 		cout << "Derive::func1()" << endl;
// 	}

// 	virtual void func3() 
// 	{ 
// 		cout << "Derive::func3()" << endl; 
// 	}

// 	virtual void func4() 
// 	{ 
// 		cout << "Derive::func4()" << endl; 
// 	}
// private:
// 	int _b;
// };

/*
在单继承关系当中，派生类的虚表生成过程如下：

1、继承基类的虚表内容到派生类的虚表。
2、对派生类重写了的虚函数地址进行覆盖，比如func1。
3、虚表当中新增派生类当中新的虚函数地址，比如func3和func4。
*/

//多继承中的虚函数表
//基类1
// class Base1
// {
// public:
// 	virtual void func1() { cout << "Base1::func1()" << endl; }
// 	virtual void func2() { cout << "Base1::func2()" << endl; }
// private:
// 	int _b1;
// };

// //基类2
// class Base2
// {
// public:
// 	virtual void func1() { cout << "Base2::func1()" << endl; }
// 	virtual void func2() { cout << "Base2::func2()" << endl; }
// private:
// 	int _b2;
// };

// //子类
// class Derive : public Base1, public Base2
// {
// public:
// 	virtual void func1() { cout << "Derive::func1()" << endl; }
// 	virtual void func3() { cout << "Derive::func3()" << endl; }
// private:
// 	int _d1;
// };

/*
在多继承关系当中，派生类的虚表生成过程如下：

1、分别继承各个基类的虚表内容到派生类的各个虚表当中。
2、对派生类重写了的虚函数地址进行覆盖(派生类中的各个虚表中存有该被重写虚函数地址的都需要进行覆盖)，比如func1。
3、在派生类第一个继承基类部分的虚表当中新增派生类当中新的虚函数地址，比如func3。

*/

// 父类A
class A
{
public:
	virtual void funcA()
	{
		cout << "A::funcA()" << endl;
	}
private:
	int _a;
};

// 子类B
class B : virtual public A
{
public:
	virtual void funcA()
	{
		cout << "B::funcA()" << endl;
	}
	virtual void funcB()
	{
		cout << "B::funcB()" << endl;
	}
private:
	int _b;
};

// 子类C
class C : virtual public A
{
public:
	virtual void funcA()
	{
		cout << "C::funcA()" << endl;
	}
	virtual void funcC()
	{
		cout << "C::funcC()" << endl;
	}
private:
	int _c;
};

// 孙子类D
class D : public B, public C
{
public:
	virtual void funcA()
	{
		cout << "D::funcA()" << endl;
	}
	virtual void funcD()
	{
		cout << "D::funcD()" << endl;
	}
private:
	int _d;
};

int main()
{
	;
	return 0;
}

/*
其中，
A类当中有一个虚函数funcA，
B类当中有一个虚函数funcB，
C类当中有一个虚函数funcC，
D类当中有一个虚函数funcD。
此外B类、C类和D类当中均对A类当中的funcA进行了重写。


A类对象的成员包括一个虚表指针和成员变量_a，虚表指针指向的虚表当中存储的是A类虚函数funcA的地址。


B类由于是虚拟继承的A类，所以B类对象当中将A类继承下来的成员放到了最后，
除此之外，B类对象的成员还包括一个虚表指针、一个虚基表指针和成员变量_b，
虚表指针指向的虚表当中存储的是B类虚函数funcB的地址。
虚基表当中存储的是两个偏移量，
第一个是虚基表指针距离B虚表指针的偏移量，
第二个是虚基表指针距离虚基类A的偏移量。


C类也是虚拟继承的A类，所以C类对象当中将A类继承下来的成员放到了最后，
除此之外，C类对象的成员还包括一个虚表指针、一个虚基表指针和成员变量_c，
虚表指针指向的虚表当中存储的是C类虚函数funcC的地址。
虚基表当中存储的是两个偏移量，
第一个是虚基表指针距离C虚表指针的偏移量，
第二个是虚基表指针距离虚基类A的偏移量。


D类对象当中成员的分布情况较为复杂，
D类的继承方式是菱形虚拟继承，
在D类对象当中，将A类继承下来的成员放到了最后，
除此之外，D类对象的成员还包括从B类继承下来的成员和成员变量_b。
从C类继承下来的成员和成员变量_d。
需要注意的是，D类对象当中的虚函数funcD的地址是存储到了B类的虚表当中。

实际中我们不建议设计出菱形继承及菱形虚拟继承，
一方面太复杂容易出问题，
另一方面使用这样的模型访问基类成员有一定的性能损耗。
*/



/*
问答题

1、什么是多态？
多态是指不同继承关系的类对象，去调用同一函数，产生了不同的行为。多态又分为静态的多态和动态的多态。

2、什么是重载、重写(覆盖)、重定义(隐藏)？
重载是指两个函数在同一作用域，这两个函数的函数名相同，参数不同。
重写(覆盖)是指两个函数分别在基类和派生类的作用域，这两个函数的函数名、参数、返回值都必须相同(协变例外)，且这两个函数都是虚函数。
重定义(隐藏)是指两个函数分别在基类和派生类的作用域，这两个函数的函数名相同。若两个基类和派生类的同名函数不构成重写就是重定义。

3、多态的实现原理？
构成多态的父类对象和子类对象的成员当中都包含一个虚表指针，
这个虚表指针指向一个虚表，虚表当中存储的是该类对应的虚函数地址。
因此，当父类指针指向父类对象时，通过父类指针找到虚表指针，然后在虚表当中找到的就是父类当中对应的虚函数；
当父类指针指向子类对象时，通过父类指针找到虚表指针，然后在虚表当中找到的就是子类当中对应的虚函数。

4、inline函数可以是虚函数吗？
我们知道内联函数是会在调用的地方展开的，也就是说内联函数是没有地址的，
但是内联函数是可以定义成虚函数的，当我们把内联函数定义虚函数后，编译器就忽略了该函数的内联属性，
这个函数就不再是内联函数了，因为需要将虚函数的地址放到虚表中去。

5、静态成员函数可以是虚函数吗？
静态成员函数不能是虚函数，因为静态成员函数没有this指针，
使用类型::成员函数的调用方式无法访问虚表，所以静态成员函数无法放进虚表。

6、构造函数可以是虚函数吗？
构造函数不能是虚函数，因为对象中的虚表指针是在构造函数初始化列表阶段才初始化的，

7、析构函数可以是虚函数吗？什么场景下析构函数是虚函数？
析构函数可以是虚函数，并且最后把基类的析构函数定义成虚函数。
若是我们分别new一个父类对象和一个子类对象，并均用父类指针指向它们，
当我们使用delete调用析构函数并释放对象空间时，
只有当父类的析构函数是虚函数的情况下，才能正确调用父类和子类的析构函数分别对父类和子类对象进行析构，
否则当我们使用父类指针delete对象时，只能调用到父类的析构函数。

8、对象访问普通函数快还是虚函数更快？
对象访问普通函数比访问虚函数更快，若我们访问的是一个普通函数，那直接访问就行了，
但当我们访问的是虚函数时，我们需要先找到虚表指针，然后在虚表当中找到对应的虚函数，最后才能调用到虚函数。

9、虚函数表是在什么阶段生成的？存在哪的？
虚表是在构造函数初始化列表阶段进行初始化的，虚表一般情况下是存在代码段(常量区)的。

10、C++菱形继承的问题？虚继承的原理？
菱形虚拟继承因为子类对象当中会有两份父类的成员，因此会导致数据冗余和二义性的问题。
虚继承对于相同的虚基类在对象当中只会存储一份，若要访问虚基类的成员需要通过虚基表获取到偏移量，
进而找到对应的虚基类成员，从而解决了数据冗余和二义性的问题。

11、什么是抽象类？抽线类的作用？
抽象类很好的体现了虚函数的继承是一种接口继承，
强制子类去抽象纯虚函数，因为子类若是不抽象从父类继承下来的纯虚函数，那么子类也是抽象类也不能实例化出对象。
其次，抽象类可以很好的去表示现实世界中没有示例对象对应的抽象类型，比如：植物、人、动物等。
*/